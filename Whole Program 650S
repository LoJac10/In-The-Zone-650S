#pragma config(UART_Usage, UART2, uartVEXLCD, baudRate19200, IOPins, None, None)
#pragma config(Sensor, in1,    power,         sensorAnalog)
#pragma config(Sensor, dgtl1,  quadL,          sensorQuadEncoder)
#pragma config(Sensor, dgtl3,  quadR,          sensorQuadEncoder)
#pragma config(Motor,  port1,           claw,          tmotorVex393_HBridge, openLoop)
#pragma config(Motor,  port2,           mogoR,     			tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port3,           mogoL,     			tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port4,          	elevatorL,        tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port5,           elevatorR,         tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port6,           armL,          tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port7,           armR,          tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port8,           driveL,        tmotorVex393_MC29, openLoop, driveLeft)
#pragma config(Motor,  port9,           driveR,        tmotorVex393_MC29, openLoop, driveRight)
#pragma config(Motor,  port10,           ,             tmotorVex393_HBridge, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard                  !!*//


/*==============================================================================================================*\
|*						- Robot Wiring Diagram -					*|
|*					  - ROBOTC 4.56 (9134) on VEX Cortex -					*|
|*														*|
|*    MOTORS & SENSORS:                                                                         		*|
|*    [I/O Port]		[Name]			[Type]              	[Description]			*|
|*==============================================================================================================*|																																																		*|
|*	UART Port 1									        		*|
|*	UART Port 2 		none			VEX LCD			VEX LCD Screen          	*|
|*--------------------------------------------------------------------------------------------------------------*|																																																		*|
|*	I2C													*|
|*--------------------------------------------------------------------------------------------------------------*|																																																		*|
|*	Analog Port 1		pwrExp						Status Line			*|
|*	Analog Port 2									        		*|
|*	Analog Port 3												*|
|*	Analog Port 4												*|
|*	Analog Port 5												*|
|*	Analog Port 6												*|
|*	Analog Port 7												*|
|*	Analog Port 8												*|
|*--------------------------------------------------------------------------------------------------------------*|																																																		*|
|*	Motor Port 1		claw			393 Motors		claw motor			*|
|*	Motor Port 2		elevatorL		393 Motors		Elevator Lift Left		*|
|*	Motor Port 3		elevatorR		393 Motors		Elevator Lift Right		*|
|*	Motor Port 4		mogoL			393 Motors		Mobile Goal Lift Left		*|
|*	Motor Port 5		mogoR			393 Motors		Mobile Goal Lift Right		*|
|*	Motor Port 6		armL			393 Motors		Arm Lift Left			*|
|*	Motor Port 7		armR			393 Motors		Arm Lift Right			*|
|*	Motor Port 8		driveL			393 Motors		drive motors left		*|
|*	Motor Port 9		driveR			393 Motors		drive motors right		*|
|*	Motor Port 10												*|
|*--------------------------------------------------------------------------------------------------------------*|																																																		*|
|*	Digital Port 1		quadL			Quad Encoder		Quadrature Encoder		*|
|*	Digital Port 2					Quad Encoder		Quadrature Encoder		*|
|*	Digital Port 3		quadR			Quad Encoder		Quadrature Encoder		*|
|*	Digital Port 4					Quad Encoder		Quadrature Encoder		*|
|*	Digital Port 5												*|
|*	Digital Port 6												*|
|*	Digital Port 7												*|
|*	Digital Port 8												*|
|*	Digital Port 9												*|
|*	Digital Port 10												*|
|*	Digital Port 11												*|
|*	Digital Port 12												*|
|*	Digital Port SP												*|
\*===============================================================================================================*/

//////////////////////////////////////////////////////////////////////////////////////////
//
//	COMPONENT TITLE: PROGRAM FOR ROBOT 650S	
//	PROJECT TITLE:	VEX ROBOTIC COMPEITION 2K17_18
//	PROGRAM AUTHOR(S): NMS ROBOTICS TEAM
//
//////////////////////////////////////////////////////////////////////////////////////////

#pragma platform(VEX2)
#pragma competitionControl(Competition)
#include "Vex_Competition_Includes.c"   

#define PI 3.14159265359

//////////////////////////////////////////////////////////////////////////////////////////
//
//                          GLOBAL VARIABLES																						//
//
// 	You may want to create some user defined functions for your program.
//
//////////////////////////////////////////////////////////////////////////////////////////

int autonomousMode = 1;						//default value for autonomous mode
int driverControlModeCount = 1;

//////////////////////////////////////////////////////////////////////////////////////////
//																											//
//                          CONSTANT VARIABLES																					//
//																												//
// 	You may want to create some user constant variables for your program.
//
//////////////////////////////////////////////////////////////////////////////////////////

//const float WHEEL_CIRC = 4*PI;
//const float EFFECTIVE_CIRC = WHEEL_CIRC*sqrt(2);
//const float TICKS_PER_REVOLUTION = 627.2;
//const int MAX_OUT = MAX_MOTOR_POWER_FWD;
//const int SPEED393_HIGHSPEED = 160;
const int DEADBAND = 25;
const int MOBILESPEED_STANDARD = 127;
const int ARMSPEED_STANDARD = 120;
const int CLAWSPEED_STANDARD = 100;
const int SPEED393_STANDARD = 100;


//------------------------------------------------------------------------------------------ GLOBAL VARIABLES

	int q1, q2, q3, q4;					// variables to record ditance for testing
	int encoderTicks = 360; 				// number of ticks in a revolution.
																								// QSE = 360. IEM = 627.2 @ 100rpm gearing.
																								// 392 @ 160 rpm gearing
	int wheelDiameter = 4;					// set the wheel diameter in inches
	//int mogoSpeed;					// power setting for mobile goals
	//int mogoMsec;						// wait time for mobile goals
																								// called in encoder functions.
																								// use float and 10.16 for cm.
	int wheelCirc = wheelDiameter * PI;			// circumference of wheel measurement calc.
	int ticksPerInch = encoderTicks / wheelCirc; 		// calc to gen #ticks / inch.

	int varSysTime = nSysTime;


//////////////////////////////////////////////////////////////////////////////////////////
//
//                         USER DEFINED FUNCTIONS				
//				FOR ROBOT CONTROL
//
// 	Insert the functions that control different aspects of your robot	
//
//////////////////////////////////////////////////////////////////////////////////////////


//------------------------------------------------------------------------------------------ FUNCTION: DRIVE TRAIN CONTROL
void
driveTrain_func(){

	motor[driveR] = abs(vexRT[Ch2]) > DEADBAND ? -vexRT[Ch2] : 0;
	motor[driveL] = abs(vexRT[Ch3]) > DEADBAND ? vexRT[Ch3] : 0;

	/* TRADITIONAL
	while(true){
		motor[drivetrain_L] = vexRT(Ch3);
		motor[drivetrain_R] = vexRT(Ch2);
	}
	*/
}

//------------------------------------------------------------------------------------------ FUNCTION: TOWER ELEVATOR LIFT
void
towerLift_func(){
		 while(true){
		  if(vexRT[Btn5U] == 1){
    		motor[elevatorL] = -SPEED393_STANDARD;
    		motor[elevatorR] = SPEED393_STANDARD;}
    	//lower tower lift
    	else if(vexRT[Btn5D] == 1){
    		motor[elevatorL] = SPEED393_STANDARD;
    		motor[elevatorR] = -SPEED393_STANDARD;}
    	//hold steady
    	else
    	{motor[elevatorL] = 0;
    	 motor[elevatorR] = 0;}
  	}
}

//------------------------------------------------------------------------------------------ FUNCTION: ARM LIFT
void
armLift_func(){
		 while(true){

    	 if(vexRT[Btn6U] == 1){
	    		motor[armL] = -ARMSPEED_STANDARD;
	    		motor[armR] = ARMSPEED_STANDARD;
	    		}
	    		//lower arm lift
	    	else if(vexRT[Btn6D] == 1){
	    		motor[armL] = ARMSPEED_STANDARD;
	    		motor[armR] = -ARMSPEED_STANDARD;
	    		}
	    		//hold steady
	    	else
	    	{motor[armL] = 0;
	    	 motor[armR] = 0;
	    	}
  	}
}

//------------------------------------------------------------------------------------------	FUNCTION: MOBILE LIFT
void
shovelLift_func(){
    while(true){

    if(vexRT[Btn7U] == 1){
    		motor[mogoL] = -MOBILESPEED_STANDARD;
    		motor[mogoR] = MOBILESPEED_STANDARD;}

    	//lower shovel lift
    	else if(vexRT[Btn7D] == 1){
    		motor[mogoL] = MOBILESPEED_STANDARD;
    		motor[mogoR] = -MOBILESPEED_STANDARD;}

    	//hold steady
    	else
    	{motor[mogoL] = 0;
    	 motor[mogoR] = 0;}
  	}
}

//------------------------------------------------------------------------------------------	FUNCTION: CLAW
void
claw_func(){
    while(true){

    	if(vexRT[Btn8R] == 1){
    		motor[claw] = CLAWSPEED_STANDARD;
    		}
    	//close claw
    	else if(vexRT[Btn8L] == 1){
    		motor[claw] = -CLAWSPEED_STANDARD;
    		}
    	//hold steady
    	else{
    		motor[claw] = 0;
    		}
  	}
}

//------------------------------------------------------------------------------------------	FUNCTION: CLEAR ENCODERS
void
zeroEncoders_func(){
	//Clear the encoders associated with the left and right drive train motors
	//nMotorEncoder[leftQuadEncoder] = 0;
	//nMotorEncoder[rightQuadEncoder] = 0;

	//Commands for 393 Integrated Motor Encoder to Reset Encoder Counts to Zero
	resetMotorEncoder(driveL);				// reset back left encoder count to zero
	resetMotorEncoder(driveR);				// reset back right encoder count to zero
}

///////////////////////////////////////////////////////////////////////////////////////////////////// 
//
//	AUTON USER FUNCTIONS
//
/////////////////////////////////////////////////////////////////////////////////////////////////////

//------------------------------------------------------------------------------------------	DRIVE FUNCTIONS: FORWARD
void autoDrive(int speed){
	motor[driveR] = -speed;					// 'Y' motors RightFront and RightBack
	motor[driveL] = speed;					// 'Y' motors LeftFront and LeftBack
	//motor[] = speed;														// open commmand for programming motors individually
	//motor[] = speed;														// open commmand for programming motors individually
}

/*
void autoDriveTime(int speed, int mSec){
	autoDrive(speed);
	wait1Msec(mSec);
	autoDrive(0);
}
*/

void clearEncoders(){
	SensorValue[quadL] = 0;
	SensorValue[quadR] = 0;
}

void autoDriveDist(int speed, int dist){
	int tickGoal = ticksPerInch * dist;

	/*
	while((abs(SensorValue[quadL])) < tickGoal * 0.6){
		//check for right encoder differences
		int rDiff = abs((SensorValue[quadL])) - abs(SensorValue[quadR]);
		//rMod = 10% speed n the direction of rDiff
		int rMod = sgn(rDiff)*speed*0.1;
	}
	*/

	while(abs(SensorValue[quadL]) < tickGoal){
			autoDrive(speed);
		}
		autoDrive(0);
	}

void raiseMogo(int mogoSpeed, int mogoMsec){
		motor[mogoL] = mogoSpeed;
		motor[mogoR] = -mogoSpeed;
		wait1Msec(mogoMsec);
}

void lowerMogo(int mogoSpeed, int mogoMsec){
		motor[mogoL] = -mogoSpeed;
		motor[mogoR] = mogoSpeed;
		wait1Msec(mogoMsec);
}

void stopMOGO(){
	motor[mogoL] = 0;
	motor[mogoR] = 0;
	}


//------------------------------------------------------------------------------------------	DRIVE FUNCTIONS:TURN FUNCTIONS

//function to turn the robot at a specified speed
//positive speed = turn right, negative speed = turn left

void
autoturn(int speed){
	motor[driveR] = speed;
	motor[driveL] = speed;
	//motor[] = speed;	//open commmand encase of programming motors individually
	//motor[] = speed; 	//open commmand encase of programming motors individually
}

/*
void autoDriveTime(int speed, int mSec){
	autoDrive(speed);
	wait1Msec(mSec);
	autoDrive(0);
}
*/

void autoTurnDist(int speed, int dist){
	int tickGoal = ticksPerInch * dist;
		while(abs(SensorValue[quadL]) < tickGoal)
		{
			autoturn(speed);
		}
	autoturn(0);
}



//////////////////////////////////////////////////////////////////////////////////////////
//																																											//
//	USER DEFINED FUNCTIONS																				//
//	FOR PROGRAM CONTROL & LCD DISPLAY																//
//																																																									//
//////////////////////////////////////////////////////////////////////////////////////////

//------------------------------------------------------------------------------------------ FUNCTION: CLEAR LCD
void
clearLCD(){
	//clears 1st & 2nd lines of the LCD
	clearLCDLine(0);	// 1st line of LCD
	clearLCDLine(1);	// 2nd line of LCD
}

//------------------------------------------------------------------------------------------ FUNCTION: PLACE HOLDER LCD DISPLAY INFORMATION
void
nothingOnScreen(){
	displayLCDCenteredString(0, "Currently"); // Msg Output to 1st line of LCD
	displayLCDCenteredString(1, "Empty");			// Msg Output to 2nd line of LCD
}

//------------------------------------------------------------------------------------------ FUNCTION: LCD DISPLAY OF ENCODER VALUES
void
displayEncoderValues(){
	displayLCDCenteredString(0,"Left      Right");
	displayLCDNumber(1,1,SensorValue[driveL],5);
	displayLCDNumber(1,9,SensorValue[driveR],5);
	if(nLCDButtons == 2){
		SensorValue[driveL] = 0;
		SensorValue[driveR] = 0;
	}
}

//------------------------------------------------------------------------------------------ FUNCTION: DISPLAY MAIN BATTERY VOLTAGE VIA LCD
////////////////////////////////////////////////////////////////////////
//
// BATTERY LCD DISPLAY PROGRAM
//
////////////////////////////////////////////////////////////////////////

//------------------------------------------------------------------------------------------
// FUNCTION: LCD DISPLAY RESET
//------------------------------------------------------------------------------------------

void
clearLCD(){
	clearLCDLine(0);
	clearLCDLine(1);
}

//------------------------------------------------------------------------------------------
// FUNCTION: LCD DISPLAY CORTEX AND POWER EXPANDER BATTERY VOLTAGES
//------------------------------------------------------------------------------------------

// Modified from Kypyro's post <https://www.vexforum.com/index.php/31293-power-expander-battery-voltage/0>
// would need a separate func to display 9-VOLT BATTERY info

void
monitorPower(){
	// turn on LCD backlight
	bLCDBacklight = true;
	// declare string vars to hold battery volt values
	string cortexBattery, expanderBattery;

	// Builds the value to be displayed
	// Value is typecast as 'FLOAT' var type
	// CHANGE: two places of data are added after decimal and the 'c' is a character ref to be replaced with the 'V' for Volt
	sprintf(cortexBattery, "%1.2f%c", nImmediateBatteryLevel/1000.0,'V');
	// KYPYRO FORM OF LINE ABOVE: sprintf(cortexBattery, "%f Volts", (float)nImmediateBatteryLevel/1000.0);
	// with the typecast redefine '%1.2f%c' there does not need to be an explicit type recast --> ie (float)
	// the value is taken from stream and recast with (2) needed decimal places
	// if you want 3 decimal places, plan for extra space, and use '%1.3f%c'

	// Expander has sensor port that connects to Analog Sensor port #2 on cortex
	// Analog Sensor port #2 is named as "power"

	// Builds Value to be Displayed
	// Value is typecast as 'FLOAT' var type
	// CHANGE: two places of data are added after decimal and the 'c' is a character ref to be replaced with the 'V' for Volt
	sprintf(expanderBattery,"%1.2f%c", ((SensorValue[power])/270.0), 'V');
	// KYPYRO FORM OF LINE ABOVE: sprintf(expanderBattery, "%f Volts", (float)SensorValue[power]/270.0);
	// with the typecast redefine '%1.2f%c' there does not need to be an explicit type recast --> ie (float)
	// the value is taken from stream and recast with (2) needed decimal places
	// if you want 3 decimal places, plan for extra space, and use '%1.3f%c'

	// clear LCD
	clearLCDLine(0);
	clearLCDLine(1);

	// displays cortex battery info on LCD Lines 1
	displayLCDString(0,0,"Cortex:");
	displayLCDString(0,8, cortexBattery);
	// displays power expander battery info on LCD line 2
	displayLCDString(1,0,"Expander:");
	displayLCDString(1,10,expanderBattery);

	// Short delay for refresh rate
	wait1Msec(1000);
	// turn off LCD backlight
	bLCDBacklight = false;
}

//------------------------------------------------------------------------------------------ FUNCTION: AUTON PROGRAM SWAP OPTION
void
swapAuton(){
	displayLCDCenteredString(0,"Autonomous");
	displayLCDCenteredString(1,"Swap");
	displayLCDNumber(0,14,autonomousMode,2);

	if(nLCDButtons == 2){
		autonomousMode++;
		while(nLCDButtons == 2){wait1Msec(10);}
	}

	if(autonomousMode > 12){
		autonomousMode = 1;
	}
}

//------------------------------------------------------------------------------------------ FUNCTION: AUTON MODE LCD START OPTION
void
startAuton(){
	displayLCDCenteredString(0, "press center to");
	displayLCDCenteredString(1, "start autonomous");
}

//////////////////////////////////////////////////////////////////////////////////////////
//																																											//
//	AUTONOMOUS MODE																				//
//	SETUP SECTION																					//
//																																											//
//////////////////////////////////////////////////////////////////////////////////////////

//------------------------------------------------------------------------------------------ FUNCTION: AUTON MODE SELECTOR PROGRAM

void
autonomousSelection(){
	//Turn on the LCD backlight
	bLCDBacklight = true;
	//Func call to clear LCD screen
	clearLCDLine(0);
	clearLCDLine(1);

	while(nLCDButtons != 2)
	{
		displayLCDCenteredString(0,"Autonomous");
		displayLCDNumber(0,14,autonomousMode, 2);
		displayLCDCenteredString(1,"<< Selection >>");
		if(nLCDButtons == 1){
			autonomousMode--;
			while(nLCDButtons == 1){wait1Msec(10);}
		}
		if(nLCDButtons == 4){
			autonomousMode++;
			while(nLCDButtons == 4){wait1Msec(10);}
		}
		if(autonomousMode < 1){
			autonomousMode = 12;
		}
		else if(autonomousMode > 12){
			autonomousMode = 1;
		}
		wait1Msec(10);
	}

	//clear the LCD screen
	clearLCDLine(0);
	clearLCDLine(1);

	//Turn off LCD backlight
	bLCDBacklight = false;
}

//////////////////////////////////////////////////////////////////////////////////////////////////////
//
//	FUNCTION -- 12 AUTONOMOUS MODE PROGRAM SLOTS
//
//////////////////////////////////////////////////////////////////////////////////////////////////////

//------------------------------------------------------------------------------------------ AUTONOMOUS PROGRAM #1
void
autonomous1(){
	clearEncoders();				// clear sensor for clean start
	lowerMogo(60, 1000);				// lower MOGO
	//lowerMogo(0, 250);

	// straight run command: part 1 -- LOW POWER FOR ALIGN
	autoDriveDist(60,30);
	clearEncoders();
	// straight run command: part 2 -- POWER UP TO GRAB MOGO
	autoDriveDist(95,20);
	raiseMogo(90, 500);
	stopMOGO();
	// raise MOGO after retrieve MOGO
	//raiseMogo(0, 250);
	wait1Msec(500);
	clearEncoders();

	//------------------------------------------------------------------------------------------

	// back up for clearing MOGO pick area with cones obstacles
	autoDriveDist(-70,40);
	clearEncoders();

	// turn command to drive forward to position robot in center of score zone
	autoTurnDist(-50,20);
	clearEncoders();

	// straight run command to position robot in center of score zone
	autoDriveDist(60,10); // distance to MOGO target
	clearEncoders();

	//------------------------------------------------------------------------------------------

	// turn to face score corner
	autoTurnDist(-60,8);
	clearEncoders();

	// 	straight run to enter score zone -- POWER UP
	autoDriveDist(120,17);
	//	motor[driveR] = -120;		//	max power
	//	motor[driveL] = 120;		// max power
	clearEncoders();


	// lower MOGO
	lowerMogo(120,1000);
	clearEncoders();

	// back up for dropping MOGO -- POWER UP
	autoDriveDist(-120,17);
	clearEncoders();
}

//------------------------------------------------------------------------------------------ AUTON PROGRAM #2
void
autonomous2(){
	//insert autonomous mode program #2 below
	//remove this func when you place your assigned func to this slot
	nothingOnScreen();
}

//------------------------------------------------------------------------------------------ AUTON PROGRAM #3
void
autonomous3(){
	//insert autonomous mode program #3 below
	//remove this func when you place your assigned func to this slot
	nothingOnScreen();
}

//------------------------------------------------------------------------------------------ AUTON PROGRAM #4
void
autonomous4(){
	//insert autonomous mode program #4 below
	nothingOnScreen(); //remove this func when you place your assigned func to this slot
}

//------------------------------------------------------------------------------------------ AUTON PROGRAM #5
void
autonomous5(){
	//insert autonomous mode program #5 below
	nothingOnScreen(); //remove this func when you place your assigned func to this slot
}

//------------------------------------------------------------------------------------------ AUTON PROGRAM #6
void
autonomous6(){
	//insert autonomous mode program #6 below
	nothingOnScreen(); //remove this func when you place your assigned func to this slot
}

//------------------------------------------------------------------------------------------ AUTON PROGRAM #7
void
autonomous7(){
	//insert autonomous mode program #7 below
	nothingOnScreen(); //remove this func when you place your assigned func to this slot
}

//------------------------------------------------------------------------------------------ AUTON PROGRAM #8
void
autonomous8(){
	//insert autonomous mode program #8 below
	nothingOnScreen(); //remove this func when you place your assigned func to this slot
}

//------------------------------------------------------------------------------------------ AUTON PROGRAM #9
void
autonomous9(){
	//insert autonomous mode program #9 below
	nothingOnScreen(); //remove this func when you place your assigned func to this slot
}

//------------------------------------------------------------------------------------------ AUTON PROGRAM #10
void
autonomous10(){
	//insert autonomous mode program #10 below
	nothingOnScreen(); //remove this func when you place your assigned func to this slot
}

//------------------------------------------------------------------------------------------ AUTON PROGRAM #11
void
autonomous11(){
	//insert autonomous mode program #11 below
	nothingOnScreen(); //remove this func when you place your assigned func to this slot
}

//------------------------------------------------------------------------------------------ AUTON PROGRAM #12
void
autonomous12(){
	//insert autonomous mode program #12 below
	nothingOnScreen(); //remove this func when you place your assigned func to this slot
}

//////////////////////////////////////////////////////////////////////////////////////////
//																																											//
//	DRIVER CONTROL MODE																		//
//	TASK SETUP SECTION																		//
//																																											//
//////////////////////////////////////////////////////////////////////////////////////////

/*=======================================================================================*\
|				DRIVER CONTROL MODE 																	|
|				BASIC ROBOT OPERATION TASKS 														|
/*=======================================================================================*/

/*---------------------------------------------------------------------------------------*\
DESCRIPTION:	TASK TO IMPLEMENT DRIVE TRAIN FUNCTIONS
/*---------------------------------------------------------------------------------------*/
task
driveBase_t(){
	while(true){
		driveTrain_func();
	}
}

/*---------------------------------------------------------------------------------------*\
DESCRIPTION:	TASK TO IMPLEMENT TOWER LIFT FUNCTIONS
/*---------------------------------------------------------------------------------------*/
task
towerLift_t(){
	while(true){
		towerLift_func();
	}
}

/*---------------------------------------------------------------------------------------*\
DESCRIPTION:	TASK TO IMPLEMENT ARM LIFT FUNCTIONS
/*---------------------------------------------------------------------------------------*/
task
armLift_t(){
	while(true){
		armLift_func();
	}
}

/*---------------------------------------------------------------------------------------*\
DESCRIPTION:	TASK TO IMPLEMENT MOGO LIFT FUNCTIONS		
/*---------------------------------------------------------------------------------------*/
task
shovelLift_t(){
	while(true){
		shovelLift_func();
	}
}

/*---------------------------------------------------------------------------------------*\
DESCRIPTION:	TASK TO IMPLEMENT CLAW FUNCTIONS	
/*---------------------------------------------------------------------------------------*/
task
claw_t(){
	while(true){
		claw_func();
	}
}

/*=======================================================================================*\
|				DRIVER CONTROL MODE 																 			|
|				DISPLAY TASK SETUP SECTION &								 									|
|				DRIVER MODE DISPLAY PROGRAMS														 			|
/*=======================================================================================*/

/*---------------------------------------------------------------------------------------*\
TYPE:						TASK
DESCRIPTION:		DRIVER CONTROL VIEW VALUES FOR LCD DISPLAY
BONAFIDES:
/*---------------------------------------------------------------------------------------*/
task
driverControlViewValues(){
	//Turn on LCD backlight
	bLCDBacklight = true;
	//Func call to clear LCD screen
	clearLCDLine(0);
	clearLCDLine(1);

	while(true){
		if(nLCDButtons == 1){
			driverControlModeCount--;
			//Func call to clear LCD screen
			clearLCDLine(0);
			clearLCDLine(1);
			while(nLCDButtons == 1){wait1Msec(10);}
		}
		if(nLCDButtons == 4){
			driverControlModeCount++;
			clearLCDLine(0);
			clearLCDLine(1);
			while(nLCDButtons == 1){wait1Msec(10);}
		}
		if(driverControlModeCount < 1){
			driverControlModeCount = 12;
		}
		else if (driverControlModeCount > 12){
			driverControlModeCount = 1;
		}

		// ...........................................................................................
		//	List below are 12 drive controll mode program call slots
		//	If a program is not installed for slot (case) then LCD reads "Nothing On Screen"
		//	There are 12 possible slots (cases) for driver controll programs to be inserted
		//	The number of 12 program slots (cases) was chosen at random and has no specific reasoning
		// ............................................................................................

		switch
		(driverControlModeCount){
		//--------------------------------------------------------------------------------------
		case 1:
			//driver control mode program #1: DISPLAY BATTERY VOLTAGE PROGRAM
			monitorPower();
			break;
		//--------------------------------------------------------------------------------------
		case 2:
			//driver control mode program #3: SWAP AUTONOMOUS MODE PROGRAMS OPTION
			swapAuton();
			break;
		//--------------------------------------------------------------------------------------
		case 3:
			//driver control mode program #4: START AUTONOMOUS MODE PROGRAMS OPTION
			startAuton();
			break;
		//--------------------------------------------------------------------------------------
		case 4:
			//driver control mode program #5: DISPLAY ENCODER VALUES
			//displayEncoderValues();
			displayEncoderValues();
			break;
		//--------------------------------------------------------------------------------------
		case 5:
			//driver control mode program #5: DISPLAY ENCODER VALUES
			//displayEncoderValues();
			nothingOnScreen();
			break;
		//--------------------------------------------------------------------------------------
		case 6:
			//insert driver control mode program #6 below -- CURRENTLY EMPTY
			nothingOnScreen(); //remove this func when you place your assigned func to this slot
			break;
		//--------------------------------------------------------------------------------------
		case 7:
			//insert driver control mode program#7 below -- CURRENTLY EMPTY
			nothingOnScreen(); //remove this func when you place your assigned func to this slot
			break;
		//--------------------------------------------------------------------------------------
		case 8:
			//insert driver control mode program #8 below -- CURRENTLY EMPTY
			nothingOnScreen(); //remove this func when you place your assigned func to this slot
			break;
		//--------------------------------------------------------------------------------------
		case 9:
			//insert driver control mode program #9 below -- CURRENTLY EMPTY
			nothingOnScreen(); //remove this func when you place your assigned func to this slot
			break;
		//--------------------------------------------------------------------------------------
		case 10:
			//insert driver control mode program #10 below -- CURRENTLY EMPTY
			nothingOnScreen(); //remove this func when you place your assigned func to this slot
			break;
		//--------------------------------------------------------------------------------------
		case 11:
			//insert driver control mode program #11 below -- CURRENTLY EMPTY
			nothingOnScreen(); //remove this func when you place your assigned func to this slot
			break;
		//--------------------------------------------------------------------------------------
		case 12:
			//insert driver control mode program #12 below -- CURRENTLY EMPTY
			nothingOnScreen(); //remove this func when you place your assigned func to this slot
			break;
		//--------------------------------------------------------------------------------------
		default:
			//insert driver control mode program #1 below
			monitorPower();
		//--------------------------------------------------------------------------------------
		}
		wait1Msec(10);
	}

	//Func call to clear LCD screen
	clearLCDLine(0);
	clearLCDLine(1);

	//Turn off LCD backlight
	bLCDBacklight = false;
}

//////////////////////////////////////////////////////////////////////////////////////////
//																											//
//                          PRE-AUTONOMOUS FUNCTIONS
//
// 	You may want to perform some actions before the competition starts. Do them in the
// 	following function.																																	//
//
//////////////////////////////////////////////////////////////////////////////////////////

void
pre_auton(){
	//zeroEncoders_func();
	autonomousSelection();
	bStopTasksBetweenModes = true;

}

//////////////////////////////////////////////////////////////////////////////////////////
//
//                                 AUTONOMOUS TASK 																			//
//
// 	This task is used to control your robot during the autonomous phase of a VEX 	
//	Competition. You must modify the code to add your own robot specific commands here.
//
//////////////////////////////////////////////////////////////////////////////////////////

task
autonomous(){
	switch(autonomousMode){
	//--------------------------------------------------------------------------------------
	case 1:
	// currently empty -- referencing autonomous mode function #1
		autonomous1();				
		break;
	//--------------------------------------------------------------------------------------
	case 2:
	// currently empty -- referencing autonomous mode function #2
		autonomous2();				
		break;
	//--------------------------------------------------------------------------------------
	case 3:
	// currently empty -- referencing autonomous mode function #3
		autonomous3();				
		break;
	//--------------------------------------------------------------------------------------
	case 4:
	// currently empty -- referencing autonomous mode function #4
		autonomous4();				
		break;
	//--------------------------------------------------------------------------------------
	case 5:
	//currently empty -- referencing autonomous mode function #5
		autonomous5();				
		break;
	//--------------------------------------------------------------------------------------
	case 6:
	//currently empty -- referencing autonomous mode function #6
		autonomous6();				
		break;
	//--------------------------------------------------------------------------------------
	case 7:
	//currently empty -- referencing autonomous mode function #7
		autonomous7();				
		break;
	//--------------------------------------------------------------------------------------
	case 8:
	//currently empty -- referencing autonomous mode function #8
		autonomous8();				
		break;
	//--------------------------------------------------------------------------------------
	case 9:
	//currently empty -- referencing autonomous mode function #9
		autonomous9();				
		break;
	//--------------------------------------------------------------------------------------
	case 10:
	//currently empty -- referencing autonomous mode function #10
		autonomous10();				
		break;
	//--------------------------------------------------------------------------------------
	case 11:
	//currently empty -- referencing autonomous mode function #11
		autonomous11();				
		break;
	//--------------------------------------------------------------------------------------
	case 12:
	//currently empty -- referencing autonomous mode function #12
		autonomous12();				
		break;
	//--------------------------------------------------------------------------------------
	default:
	//default autonomous program -- referencing autonomous mode function #1
		autonomous1();				
	//--------------------------------------------------------------------------------------
	}
	wait1Msec(2000);
}

//////////////////////////////////////////////////////////////////////////////////////////
//																												//
//                                 USER CONTROL TASK																		//
//																											//
// 	This task is used to control your robot during the user control phase of a VEX 		
//	Competition. You must modify the code to add your own robot specific commands here.
//
//////////////////////////////////////////////////////////////////////////////////////////

task
usercontrol(){
	clearLCDLine(0);
	clearLCDLine(1);
	startTask(driverControlViewValues);
	while(true){
		//use lcd to start autonomous or button 7R on controller
		if((driverControlModeCount == 3) && (nLCDButtons == 2)||(vexRT[Btn7R] == 1)){
				startTask(autonomous);
				wait1Msec(15000);
				stopTask(autonomous);
			}
		//main program
		startTask(driveBase_t);
		startTask(towerLift_t);
		startTask(armLift_t);
		startTask(shovelLift_t);
		startTask(claw_t);
		startTask(usercontrol);
	}
}
